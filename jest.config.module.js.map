{"version":3,"file":"jest.config.module.js","sources":["__tests__/index.tests.ts","src/lib.ts","src/index.ts"],"sourcesContent":["import { JSDOM } from \"jsdom\";\nimport { streakCounter } from \"../src/index\";\n\nexport function formattedDate(date: Date): string {\n    return date.toLocaleDateString(\"en-US\");\n}\n\ndescribe(\"streakCounter\", () => {\n\n    let mockLocalStorage: Storage;\n\n    beforeEach(() => {\n        const mockJSDom = new JSDOM(\"\", { url: \"https://localhost\" });\n\n        mockLocalStorage = mockJSDom.window.localStorage;\n    });\n\n    it(\"should return a streak object with currentCount, startDate and lastLoginDate\", () => {\n        const date = new Date();\n        const streak = streakCounter(mockLocalStorage, date);\n\n        expect(streak.hasOwnProperty(\"currentCount\")).toBe(true);\n        expect(streak.hasOwnProperty(\"startDate\")).toBe(true);\n        expect(streak.hasOwnProperty(\"lastLoginDate\")).toBe(true);\n    });\n    it(\"should return a streak starting at 1 and keep track of lastLoginDate\", () => {\n        const date = new Date();\n        const streak = streakCounter(mockLocalStorage, date);\n\n        const dateFormatted = formattedDate(date);\n\n        expect(streak.currentCount).toBe(1);\n        expect(streak.lastLoginDate).toBe(dateFormatted);\n    });\n\n    it(\"should store the streak in localStorage\", () => {\n        const date = new Date();\n        const key = \"streak\";\n        streakCounter(mockLocalStorage, date);\n\n        const streakAsString = mockLocalStorage.getItem(key);\n        expect(streakAsString).not.toBeNull();\n    });\n\n    // Separate suite to test different scenario\n    describe(\"with a pre-populated streak\", () => {\n        let mockLocalStorage: Storage;\n        beforeEach(() => {\n            const mockJSDom = new JSDOM(\"\", { url: \"https://localhost\" });\n\n            mockLocalStorage = mockJSDom.window.localStorage;\n\n            // Use date in past so itâ€™s always the same\n            const date = new Date(\"12/12/2021\");\n\n            const streak = {\n                currentCount: 1,\n                startDate: formattedDate(date),\n                lastLoginDate: formattedDate(date),\n            };\n\n            mockLocalStorage.setItem(\"streak\", JSON.stringify(streak));\n        });\n        afterEach(() => {\n            mockLocalStorage.clear();\n        });\n        it(\"should return the streak from localStorage\", () => {\n            const date = new Date();\n            const streak = streakCounter(mockLocalStorage, date);\n\n            // Should match the dates used to set up the tests\n            expect(streak.startDate).toBe(\"12/12/2021\");\n        });\n        // TODO: populate localStorage with a streak\n        it(\"should increment the streak\", () => {\n            // It should increment because this is the day after\n            // the streak started and a streak is days in a row.\n            const date = new Date(\"12/13/2021\");\n            const streak = streakCounter(mockLocalStorage, date);\n\n            expect(streak.currentCount).toBe(2);\n        });\n        it(\"should not increment the streak when login days not consecutive\", () => {\n            // It should not increment because this is two days after\n            // the streak started and the days aren't consecutive.\n            const date = new Date(\"12/14/2021\");\n            const streak = streakCounter(mockLocalStorage, date);\n\n            expect(streak.currentCount).toBe(1);\n        });\n        it(\"should save the incremented streak to localStorage\", () => {\n            const key = \"streak\";\n            const date = new Date(\"12/13/2021\");\n            // Call it once so it updates the streak\n            streakCounter(mockLocalStorage, date);\n\n            const streakAsString = mockLocalStorage.getItem(key);\n            // Normally you should wrap in try/catch in case the JSON is bad\n            // but since we authored it, we can skip here\n            const streak = JSON.parse(streakAsString || \"\");\n\n            expect(streak.currentCount).toBe(2);\n        });\n        it(\"should reset if not consecutive\", () => {\n            const date = new Date(\"12/13/2021\");\n            const streak = streakCounter(mockLocalStorage, date);\n\n            expect(streak.currentCount).toBe(2);\n\n            // Skip a day and break the streak\n            const dateUpdated = new Date(\"12/15/2021\");\n            const streakUpdated = streakCounter(mockLocalStorage, dateUpdated);\n\n            expect(streakUpdated.currentCount).toBe(1);\n        });\n        it(\"should not reset the streak for same-day login\", () => {\n            const date = new Date(\"12/13/2021\");\n            // Call it once so it updates the streak\n            streakCounter(mockLocalStorage, date);\n\n            // Simulate same-day login\n            const dateUpdated = new Date(\"12/13/2021\");\n            const streakUpdated = streakCounter(mockLocalStorage, dateUpdated);\n\n            expect(streakUpdated.currentCount).toBe(2);\n        });\n        it(\"should save the reset streak to localStorage\", () => {\n            const key = \"streak\";\n            const date = new Date(\"12/13/2021\");\n            // Call it once so it updates the streak\n            streakCounter(mockLocalStorage, date);\n\n            // Skip a day and break the streak\n            const dateUpdated = new Date(\"12/15/2021\");\n            const streakUpdated = streakCounter(mockLocalStorage, dateUpdated);\n\n            const streakAsString = mockLocalStorage.getItem(key);\n            // Normally you should wrap in try/catch in case the JSON is bad\n            // but since we authored it, we can skip here\n            const streak = JSON.parse(streakAsString || \"\");\n\n            expect(streak.currentCount).toBe(1);\n        });\n    });\n});","import { formattedDate } from \"../__tests__/index.tests\";\n\n// Used when storing in localStorage\nexport const KEY = \"streak\";\n\nexport interface Streak {\n    currentCount: number;\n    startDate: string;\n    lastLoginDate: string;\n}\n\nexport function shouldIncrementOrResetStreakCount(\n    currentDate: Date,\n    lastLoginDate: string\n): \"increment\" | \"reset\" | undefined {\n    // We get 11/5/2021\n    // so to get 5, we split on / and get the second item\n    const difference =\n        currentDate.getDate() - parseInt(lastLoginDate.split(\"/\")[1]);\n    // This means they logged in the day after the currentDate\n    if (difference === 1) {\n        return \"increment\";\n    }\n    else if (difference !== 0){\n        return \"reset\";\n    }\n    // Otherwise they logged in after a day, which would\n    // break the streak\n    return undefined;\n}\n\nexport function buildStreak(date: Date, partialStreak: Partial<Streak>): Streak {\n    let streak = {\n        currentCount: 1,\n        startDate: formattedDate(date),\n        lastLoginDate: formattedDate(date),\n        ...partialStreak\n    }\n\n    return streak;\n}","import { formattedDate } from \"../__tests__/index.tests\";\nimport { buildStreak, KEY, shouldIncrementOrResetStreakCount, Streak } from \"./lib\";\n\nexport function streakCounter(storage: Storage, date: Date): Streak {\n    const streakInLocalStorage = storage.getItem(KEY);\n    if (streakInLocalStorage) {\n        try {\n            const streak = JSON.parse(streakInLocalStorage);\n            const state = shouldIncrementOrResetStreakCount(\n                date,\n                streak.lastLoginDate\n            );\n            const SHOULD_INCREMENT = state === \"increment\";\n            const SHOULD_RESET = state === \"reset\";\n\n            if (SHOULD_INCREMENT) {\n                const updatedStreak = {\n                    ...streak,\n                    currentCount: streak.currentCount + 1,\n                    lastLoginDate: formattedDate(date),\n                };\n                // store in localStorage\n                storage.setItem(KEY, JSON.stringify(updatedStreak));\n\n                return updatedStreak;\n            }\n            if (SHOULD_RESET) {\n                const resetStreak = {\n                    ...streak,\n                    currentCount: 1,\n                    lastLoginDate: formattedDate(date),\n                }\n                // store in localStorage\n                storage.setItem(KEY, JSON.stringify(resetStreak));\n\n                return resetStreak;\n            }\n            return streak;\n        } catch (error) {\n            console.error(\"Failed to parse streak from localStorage\");\n        }\n    }\n    const streak = buildStreak(date, {});\n    \n    // store in localStorage\n    storage.setItem(KEY, JSON.stringify(streak));\n    return streak;\n}"],"names":["date","toLocaleDateString","describe","mockLocalStorage","beforeEach","mockJSDom","JSDOM","url","window","localStorage","it","streakCounter","expect","streak","hasOwnProperty","toBe","dateFormatted","formattedDate","currentCount","lastLoginDate","Date","streakAsString","getItem","not","toBeNull","startDate","setItem","JSON","stringify","afterEach","clear","parse","dateUpdated","streakUpdated","KEY","storage","difference","streakInLocalStorage","getDate","parseInt","split","SHOULD_RESET","state","updatedStreak","resetStreak","_extends","error","console","partialStreak","buildStreak"],"mappings":"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"}