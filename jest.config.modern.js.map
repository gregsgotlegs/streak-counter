{"version":3,"file":"jest.config.modern.js","sources":["__tests__/index.tests.ts","src/lib.ts","src/index.ts"],"sourcesContent":["import { JSDOM } from \"jsdom\";\nimport { streakCounter } from \"../src/index\";\n\nexport function formattedDate(date: Date): string {\n    return date.toLocaleDateString(\"en-US\");\n}\n\ndescribe(\"streakCounter\", () => {\n\n    let mockLocalStorage: Storage;\n\n    beforeEach(() => {\n        const mockJSDom = new JSDOM(\"\", { url: \"https://localhost\" });\n\n        mockLocalStorage = mockJSDom.window.localStorage;\n    });\n\n    it(\"should return a streak object with currentCount, startDate and lastLoginDate\", () => {\n        const date = new Date();\n        const streak = streakCounter(mockLocalStorage, date);\n\n        expect(streak.hasOwnProperty(\"currentCount\")).toBe(true);\n        expect(streak.hasOwnProperty(\"startDate\")).toBe(true);\n        expect(streak.hasOwnProperty(\"lastLoginDate\")).toBe(true);\n    });\n    it(\"should return a streak starting at 1 and keep track of lastLoginDate\", () => {\n        const date = new Date();\n        const streak = streakCounter(mockLocalStorage, date);\n\n        const dateFormatted = formattedDate(date);\n\n        expect(streak.currentCount).toBe(1);\n        expect(streak.lastLoginDate).toBe(dateFormatted);\n    });\n\n    it(\"should store the streak in localStorage\", () => {\n        const date = new Date();\n        const key = \"streak\";\n        streakCounter(mockLocalStorage, date);\n\n        const streakAsString = mockLocalStorage.getItem(key);\n        expect(streakAsString).not.toBeNull();\n    });\n\n    // Separate suite to test different scenario\n    describe(\"with a pre-populated streak\", () => {\n        let mockLocalStorage: Storage;\n        beforeEach(() => {\n            const mockJSDom = new JSDOM(\"\", { url: \"https://localhost\" });\n\n            mockLocalStorage = mockJSDom.window.localStorage;\n\n            // Use date in past so itâ€™s always the same\n            const date = new Date(\"12/12/2021\");\n\n            const streak = {\n                currentCount: 1,\n                startDate: formattedDate(date),\n                lastLoginDate: formattedDate(date),\n            };\n\n            mockLocalStorage.setItem(\"streak\", JSON.stringify(streak));\n        });\n        afterEach(() => {\n            mockLocalStorage.clear();\n        });\n        it(\"should return the streak from localStorage\", () => {\n            const date = new Date();\n            const streak = streakCounter(mockLocalStorage, date);\n\n            // Should match the dates used to set up the tests\n            expect(streak.startDate).toBe(\"12/12/2021\");\n        });\n        // TODO: populate localStorage with a streak\n        it(\"should increment the streak\", () => {\n            // It should increment because this is the day after\n            // the streak started and a streak is days in a row.\n            const date = new Date(\"12/13/2021\");\n            const streak = streakCounter(mockLocalStorage, date);\n\n            expect(streak.currentCount).toBe(2);\n        });\n        it(\"should not increment the streak when login days not consecutive\", () => {\n            // It should not increment because this is two days after\n            // the streak started and the days aren't consecutive.\n            const date = new Date(\"12/14/2021\");\n            const streak = streakCounter(mockLocalStorage, date);\n\n            expect(streak.currentCount).toBe(1);\n        });\n        it(\"should save the incremented streak to localStorage\", () => {\n            const key = \"streak\";\n            const date = new Date(\"12/13/2021\");\n            // Call it once so it updates the streak\n            streakCounter(mockLocalStorage, date);\n\n            const streakAsString = mockLocalStorage.getItem(key);\n            // Normally you should wrap in try/catch in case the JSON is bad\n            // but since we authored it, we can skip here\n            const streak = JSON.parse(streakAsString || \"\");\n\n            expect(streak.currentCount).toBe(2);\n        });\n        it(\"should reset if not consecutive\", () => {\n            const date = new Date(\"12/13/2021\");\n            const streak = streakCounter(mockLocalStorage, date);\n\n            expect(streak.currentCount).toBe(2);\n\n            // Skip a day and break the streak\n            const dateUpdated = new Date(\"12/15/2021\");\n            const streakUpdated = streakCounter(mockLocalStorage, dateUpdated);\n\n            expect(streakUpdated.currentCount).toBe(1);\n        });\n        it(\"should not reset the streak for same-day login\", () => {\n            const date = new Date(\"12/13/2021\");\n            // Call it once so it updates the streak\n            streakCounter(mockLocalStorage, date);\n\n            // Simulate same-day login\n            const dateUpdated = new Date(\"12/13/2021\");\n            const streakUpdated = streakCounter(mockLocalStorage, dateUpdated);\n\n            expect(streakUpdated.currentCount).toBe(2);\n        });\n        it(\"should save the reset streak to localStorage\", () => {\n            const key = \"streak\";\n            const date = new Date(\"12/13/2021\");\n            // Call it once so it updates the streak\n            streakCounter(mockLocalStorage, date);\n\n            // Skip a day and break the streak\n            const dateUpdated = new Date(\"12/15/2021\");\n            const streakUpdated = streakCounter(mockLocalStorage, dateUpdated);\n\n            const streakAsString = mockLocalStorage.getItem(key);\n            // Normally you should wrap in try/catch in case the JSON is bad\n            // but since we authored it, we can skip here\n            const streak = JSON.parse(streakAsString || \"\");\n\n            expect(streak.currentCount).toBe(1);\n        });\n    });\n});","import { formattedDate } from \"../__tests__/index.tests\";\n\n// Used when storing in localStorage\nexport const KEY = \"streak\";\n\nexport interface Streak {\n    currentCount: number;\n    startDate: string;\n    lastLoginDate: string;\n}\n\nexport function shouldIncrementOrResetStreakCount(\n    currentDate: Date,\n    lastLoginDate: string\n): \"increment\" | \"reset\" | undefined {\n    // We get 11/5/2021\n    // so to get 5, we split on / and get the second item\n    const difference =\n        currentDate.getDate() - parseInt(lastLoginDate.split(\"/\")[1]);\n    // This means they logged in the day after the currentDate\n    if (difference === 1) {\n        return \"increment\";\n    }\n    else if (difference !== 0){\n        return \"reset\";\n    }\n    // Otherwise they logged in after a day, which would\n    // break the streak\n    return undefined;\n}\n\nexport function buildStreak(date: Date, partialStreak: Partial<Streak>): Streak {\n    let streak = {\n        currentCount: 1,\n        startDate: formattedDate(date),\n        lastLoginDate: formattedDate(date),\n        ...partialStreak\n    }\n\n    return streak;\n}","import { formattedDate } from \"../__tests__/index.tests\";\nimport { buildStreak, KEY, shouldIncrementOrResetStreakCount, Streak } from \"./lib\";\n\nexport function streakCounter(storage: Storage, date: Date): Streak {\n    const streakInLocalStorage = storage.getItem(KEY);\n    if (streakInLocalStorage) {\n        try {\n            const streak = JSON.parse(streakInLocalStorage);\n            const state = shouldIncrementOrResetStreakCount(\n                date,\n                streak.lastLoginDate\n            );\n            const SHOULD_INCREMENT = state === \"increment\";\n            const SHOULD_RESET = state === \"reset\";\n\n            if (SHOULD_INCREMENT) {\n                const updatedStreak = {\n                    ...streak,\n                    currentCount: streak.currentCount + 1,\n                    lastLoginDate: formattedDate(date),\n                };\n                // store in localStorage\n                storage.setItem(KEY, JSON.stringify(updatedStreak));\n\n                return updatedStreak;\n            }\n            if (SHOULD_RESET) {\n                const resetStreak = {\n                    ...streak,\n                    currentCount: 1,\n                    lastLoginDate: formattedDate(date),\n                }\n                // store in localStorage\n                storage.setItem(KEY, JSON.stringify(resetStreak));\n\n                return resetStreak;\n            }\n            return streak;\n        } catch (error) {\n            console.error(\"Failed to parse streak from localStorage\");\n        }\n    }\n    const streak = buildStreak(date, {});\n    \n    // store in localStorage\n    storage.setItem(KEY, JSON.stringify(streak));\n    return streak;\n}"],"names":["date","toLocaleDateString","describe","mockLocalStorage","beforeEach","mockJSDom","JSDOM","url","window","localStorage","it","streakCounter","expect","streak","hasOwnProperty","toBe","dateFormatted","formattedDate","currentCount","lastLoginDate","Date","streakAsString","getItem","not","toBeNull","startDate","setItem","JSON","stringify","afterEach","clear","parse","dateUpdated","streakUpdated","KEY","storage","streakInLocalStorage","shouldIncrementOrResetStreakCount","currentDate","difference","getDate","parseInt","split","SHOULD_RESET","state","updatedStreak","resetStreak","_extends","error","console","partialStreak","buildStreak"],"mappings":"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"}